current backend:
MLBackend/
â”œâ”€â”€ app.py                    # Flask + WebSocket server
â”œâ”€â”€ websocket_handler.py      # WebSocket connection management
â”œâ”€â”€ ml_model.py              # LSTM model inference
â”œâ”€â”€ data_processor.py        # Signal processing
â”œâ”€â”€ models/
â”‚   â””â”€â”€ lstm_anomaly.h5      # Your trained model
â”œâ”€â”€ config/
â”‚   â””â”€â”€ model_config.json    # Model parameters
â””â”€â”€ requirements.txt

Arduino (USB) â†’ Python WebSocket Server â†’ ML Model â†’ React Native App

How the System Works (Conceptually)
Your system is a real-time anomaly monitoring loop using embedded hardware and mobile + backend infrastructure.

Flow:
Data Generation (Arduino):

The Arduino reads analog voltage from a sensor (i.e. vibration).

It sends voltage data over serial to the HC-05 Bluetooth module, which transmits data to the app.

Data Reception (React Native App):

BluetoothService.ts handles the Bluetooth communication using react-native-bluetooth-serial-next.

Each data point (e.g. "3.45\n") is parsed via DataParser.ts.

The app sends the value to the backend via ApiService.ts.

Backend ML Inference (Flask):

The backend Flask API receives the voltage via HTTP POST (from the app).

The LSTM model processes a rolling window of recent voltages.

The backend returns a classification: normal or anomaly.

Display Results (App):

The response is shown on the app (e.g. green = normal, red = anomaly).

The chart in LiveChart.tsx updates in real time.




# System Connection Flow

## 1. Hardware Connection
```
Arduino Uno/Nano
â”œâ”€â”€ A0 Pin â†â”€â”€ Voltage Source (0-5V)
â”œâ”€â”€ D2 Pin â†â”€â”€ HC-05 TX
â”œâ”€â”€ D3 Pin â†â”€â”€ HC-05 RX
â””â”€â”€ Power â†â”€â”€ 5V + GND
```

## 2. Data Flow
```
Arduino â†’ HC-05 Bluetooth â†’ iOS App â†’ HTTP API â†’ Python ML Backend
   â†“           â†“              â†“         â†“            â†“
Voltage    JSON/String    Parse &    REST API    TensorFlow
Reading    via Serial    Display    /predict     Model
```

## 3. Real-time Processing
```
iOS App receives voltage data every 200ms:
1. Display on real-time chart
2. Update statistics
3. Buffer data for ML processing
4. Every 1 second: Send 50-point window to ML backend
5. If anomaly detected: Show alert and mark on chart
```

## 4. Component Responsibilities

### Arduino
- Read voltage from A0 pin every 200ms
- Smooth data with 10-point moving average
- Send via HC-05 as JSON: `{"voltage":3.245,"timestamp":12345}`

### iOS App
- Connect to HC-05 via Bluetooth
- Parse incoming voltage data
- Display real-time chart
- Buffer data and send to ML backend
- Show anomaly alerts

### ML Backend
- Receive POST requests with voltage sequences
- Process through trained LSTM autoencoder
- Return anomaly probability
- Maintain model in memory for fast inference

## 5. Setup Sequence

1. **Start ML Backend**: `python MLBackend/app.py`
2. **Train Model**: `python MLBackend/train_model.py`
3. **Upload Arduino Code**: Flash `voltage_monitor.ino`
4. **Pair HC-05**: Pair with iOS device (PIN: 1234 or 0000)
5. **Run iOS App**: `npx react-native run-ios`
6. **Connect**: Use app to connect to HC-05 module
7. **Monitor**: Watch real-time voltage and anomalies





Full file tree Structure:
# Complete Arduino Piezoelectric Anomaly Detection System
â”œâ”€â”€ AnomalyApp/                          # React Native mobile app
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ index.js
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â”œâ”€â”€ ConnectPanel.tsx         # UI to choose connection (Bluetooth/WebSocket)
â”‚       â”‚   â”œâ”€â”€ LiveChart.tsx            # Live vibration spectrum + anomaly chart
â”‚       â”‚   â”œâ”€â”€ MaterialSelector.tsx     # NEW: Select material profile
â”‚       â”‚   â”œâ”€â”€ CalibrationPanel.tsx     # NEW: Sensor calibration interface
â”‚       â”‚   â””â”€â”€ FrequencyAnalyzer.tsx    # NEW: Real-time frequency domain display
â”‚       â”œâ”€â”€ screens/
â”‚       â”‚   â”œâ”€â”€ HomeScreen.tsx           # Main monitoring interface
â”‚       â”‚   â”œâ”€â”€ CalibrationScreen.tsx    # NEW: Material calibration workflow
â”‚       â”‚   â”œâ”€â”€ TrainingScreen.tsx       # NEW: User training data collection interface
â”‚       â”‚   â”œâ”€â”€ DataManagementScreen.tsx # NEW: Manage collected training datasets
â”‚       â”‚   â””â”€â”€ HistoryScreen.tsx        # NEW: Anomaly history and reports
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â”œâ”€â”€ BluetoothService.ts      # HC-05 Bluetooth manager (PRIMARY CONNECTION)
â”‚       â”‚   â”œâ”€â”€ ApiService.ts            # POST vibration data to backend ML model
â”‚       â”‚   â”œâ”€â”€ MaterialProfileService.ts # NEW: Manage material-specific settings
â”‚       â”‚   â”œâ”€â”€ TrainingDataService.ts   # NEW: Manage user training data collection
â”‚       â”‚   â””â”€â”€ DataUploadService.ts     # NEW: Upload user training data to backend
â”‚       â”œâ”€â”€ utils/
â”‚       â”‚   â”œâ”€â”€ DataParser.ts            # ENHANCED: Parse and preprocess piezo signals
â”‚       â”‚   â”œâ”€â”€ SignalProcessor.ts       # NEW: FFT, filtering, feature extraction
â”‚       â”‚   â”œâ”€â”€ CalibrationUtils.ts      # NEW: Sensor calibration algorithms
â”‚       â”‚   â”œâ”€â”€ TrainingDataCollector.ts # NEW: Collect and validate user training data
â”‚       â”‚   â””â”€â”€ DataValidator.ts         # NEW: Validate quality of user-provided data
â”‚       â””â”€â”€ connection/
â”‚           â””â”€â”€ BluetoothManager.ts      # FOCUSED: Dedicated Bluetooth connection logic

â”œâ”€â”€ MLBackend/                           # Flask-based ML backend
â”‚   â”œâ”€â”€ app.py                          # ENHANCED: Main Flask server with user training endpoints
â”‚   â”œâ”€â”€ train_model.py                  # ENHANCED: LSTM training with user-provided data
â”‚   â”œâ”€â”€ retrain_model.py                # NEW: Retrain models with new user data
â”‚   â”œâ”€â”€ data_validation.py              # NEW: Validate user-uploaded training data
â”‚   â”œâ”€â”€ generate_data.py                # ENHANCED: Generate material-specific synthetic data
â”‚   â”œâ”€â”€ user_training/                  # NEW: Handle user training workflows
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ data_processor.py           # Process user-uploaded data
â”‚   â”‚   â”œâ”€â”€ training_scheduler.py       # Queue and manage retraining jobs
â”‚   â”‚   â””â”€â”€ model_versioning.py         # Version control for user-specific models
â”‚   â”œâ”€â”€ signal_processing/              # NEW: Server-side signal processing
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ frequency_analysis.py       # FFT and spectral analysis
â”‚   â”‚   â”œâ”€â”€ noise_filtering.py          # Advanced filtering algorithms
â”‚   â”‚   â””â”€â”€ feature_extraction.py       # Extract vibration characteristics
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ base_models/                # Base pre-trained models
â”‚   â”‚   â”‚   â”œâ”€â”€ concrete/
â”‚   â”‚   â”‚   â”œâ”€â”€ wood/
â”‚   â”‚   â”‚   â””â”€â”€ metal/
â”‚   â”‚   â”œâ”€â”€ user_models/                # NEW: User-specific trained models
â”‚   â”‚   â”‚   â”œâ”€â”€ user_123/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ concrete_custom/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ model.h5
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ params.json
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ training_history.json
â”‚   â”‚   â”‚   â””â”€â”€ user_456/
â”‚   â”‚   â””â”€â”€ model_registry.json         # NEW: Track all available models per user
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ base_training_data/         # Original system training data
â”‚   â”‚   â”‚   â”œâ”€â”€ concrete/
â”‚   â”‚   â”‚   â”œâ”€â”€ wood/
â”‚   â”‚   â”‚   â””â”€â”€ metal/
â”‚   â”‚   â”œâ”€â”€ user_training_data/         # NEW: User-provided training data
â”‚   â”‚   â”‚   â”œâ”€â”€ user_123/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ uploads/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ validated/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ processed/
â”‚   â”‚   â”‚   â””â”€â”€ user_456/
â”‚   â”‚   â”œâ”€â”€ calibration_data/           # Calibration reference signals
â”‚   â”‚   â””â”€â”€ frequency_templates/        # Expected frequency patterns per material
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ material_configs.json       # NEW: Material-specific parameters
â”‚   â”‚   â””â”€â”€ sensor_profiles.json        # NEW: Piezo sensor specifications
â”‚   â””â”€â”€ requirements.txt                # UPDATED: Added scipy, librosa for signal processing

â””â”€â”€ Arduino/
    â”œâ”€â”€ piezo_vibration_monitor.ino     # ENHANCED: High-frequency piezo sampling
    â”œâ”€â”€ libraries/
    â”‚   â”œâ”€â”€ PiezoCalibration/           # NEW: Custom calibration library
    â”‚   â””â”€â”€ SignalFiltering/            # NEW: Hardware-level noise filtering
    â””â”€â”€ config/
        â”œâ”€â”€ sensor_config.h             # NEW: Piezo sensor parameters
        â””â”€â”€ sampling_config.h           # NEW: Sampling rate configurations


How the Piezoelectric Anomaly Detection System Works
ðŸ”§ Phase 1: Setup & Calibration
Arduino Setup:

Arduino samples piezoelectric sensor at 5-10kHz using high-precision ADC
Hardware low-pass filter (op-amp based) removes noise above structural vibration frequencies (~2kHz)
Anti-aliasing filter prevents frequency folding in digital sampling
Calibration mode: Arduino generates test pulses and records sensor response curves
BLUETOOTH ONLY: All communication via HC-05 module (9600-115200 baud) - no WiFi dependencies

Mobile App Initial Setup:

BluetoothManager.ts scans and pairs with HC-05 device automatically
Connection status indicator shows signal strength and data flow rate
User creates account/profile for personalized model tracking
iOS-ONLY DEPLOYMENT: Simplified development focusing on single platform initially
Device pairing stored securely using iOS Keychain for automatic reconnection

Calibration Workflow:

User selects material type (concrete, wood, metal, custom) via MaterialSelector.tsx
CalibrationPanel.tsx guides through structured calibration sequence:

Ambient noise baseline (10 seconds of no-tap data)
Reference taps (20 gentle taps at different locations)
Material response mapping (tap intensity vs frequency response)


SignalProcessor.ts analyzes calibration data using FFT to establish:

Dominant frequency ranges for the material
Noise floor levels
Sensor sensitivity coefficients


Calibration parameters stored locally and uploaded for model initialization

Phase 2: User Training Data Collection (OPTIONAL)
Training Mode Activation:
User navigates to TrainingScreen.tsx â†’
Selects training type: "Expand Base Model" or "Train New Material" â†’
App displays data collection progress bar and quality metrics â†’
Real-time feedback shows signal quality and data sufficiency
Normal Data Collection:
App prompts: "Collect NORMAL vibration data from healthy areas" â†’
User systematically taps 50-100 locations on sound material â†’
TrainingDataCollector.ts records and labels each sample:
  - Tap intensity (accelerometer-derived)
  - Environmental conditions (time, temperature if available)
  - Frequency spectrum characteristics
DataValidator.ts performs real-time quality checks:
  - Signal-to-noise ratio thresholds
  - Frequency consistency validation
  - Duplicate sample detection
Anomaly Data Collection (Advanced Users):
App prompts: "Collect ANOMALY data from known problem areas" â†’
User tests confirmed defects: cracks, voids, delamination â†’
Each sample tagged with defect type and severity â†’
Visual confirmation prompts ensure proper labeling â†’
Quality validation ensures anomalies have distinct signatures
Backend Training Pipeline:
DataUploadService.ts sends training package to backend â†’
user_training/data_processor.py validates and preprocesses:
  - Removes outliers and noise artifacts
  - Balances normal vs anomaly sample ratios
  - Augments data with synthetic variations
retrain_model.py creates personalized model:
  - Combines user data with relevant base training set
  - Fine-tunes LSTM autoencoder architecture
  - Cross-validates on holdout data
model_versioning.py tracks performance metrics â†’
Push notification: "Your custom model achieved 94% accuracy!"

Phase 3: Real-Time Monitoring Loop
1. High-Frequency Data Acquisition (Arduino):
Continuous 5kHz sampling with circular buffer (1000 samples) â†’
Hardware analog filtering (Butterworth 2-pole, fc=2kHz) â†’
Digital oversampling and decimation for noise reduction â†’
Packet assembly: 50-sample windows with timestamp â†’
HC-05 transmission: "T:1698765432,V:2.34,2.45,2.12...2.67\n"
Automatic gain control adjusts for different tap intensities
2. Mobile Signal Processing (React Native App):
BluetoothManager.ts maintains connection health monitoring â†’
DataParser.ts extracts and validates incoming packets â†’
SignalProcessor.ts performs comprehensive analysis:
  - Windowing function (Hamming) to reduce spectral leakage
  - FFT analysis with 256-point resolution
  - Peak detection for dominant frequencies
  - Statistical feature extraction (RMS, crest factor, spectral centroid)
  - Rolling buffer management (3-second analysis windows)
  - Environmental noise subtraction using calibration baseline
3. Intelligent ML Inference (Flask Backend):
ApiService.ts sends feature vector + metadata:
  - Frequency domain features (spectral peaks, bandwidth)
  - Time domain statistics (variance, skewness, kurtosis)
  - User ID and material type
  - Sensor calibration parameters
  - Environmental context (if available)

Backend model selection logic:
  If user has custom model AND confidence > threshold â†’ user_models/user_123/
  Else if base model available for material â†’ base_models/concrete/
  Else â†’ generic anomaly detector with reduced confidence

LSTM autoencoder processing:
  - Reconstruction error calculation
  - Anomaly scoring with confidence intervals
  - Frequency pattern matching against known signatures
  - Temporal consistency checking (prevents single-point false positives)

Response includes:
  {
    anomaly_score: 0.23,           // 0=normal, 1=anomaly
    confidence: 0.87,              // Model certainty
    model_used: "user_custom",     // Which model processed the data
    dominant_frequency: 340.5,     // Hz
    recommendations: ["collect_more_data", "check_sensor_mounting"]
  }
4. Rich Results Display (App Interface):
LiveChart.tsx real-time dashboard:
  - Dual-axis plot: raw waveform + frequency spectrum
  - Color-coded anomaly probability timeline
  - Model type indicator with performance badge
  - Data quality indicators (SNR, connection stability)

FrequencyAnalyzer.tsx detailed analysis:
  - Waterfall plot showing frequency evolution over time
  - Comparison overlay: current vs baseline signature
  - Peak detection with frequency labeling
  - Anomaly confidence bands

AlertSystem.tsx notification management:
  - Threshold-based anomaly alerts
  - Pattern recognition for recurring issues
  - Historical trend analysis
  - Actionable recommendations (sensor repositioning, additional training data)
